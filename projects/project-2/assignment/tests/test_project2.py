# project-2/assignment/tests/test_project2.py
# Autograder for Week 2 Project: Enriching Raw Data
#
# Requires: rdflib, pytest
# Do not edit this file.

import math
from pathlib import Path
import pytest
from rdflib import Graph, URIRef, Namespace, Literal
from rdflib.namespace import RDF, RDFS, OWL, SKOS, XSD

ASSIGN = Path(__file__).resolve().parents[1]
DATA_DIR = ASSIGN / "src" / "data"

# ---- Helpers -----------------------------------------------------------------

NUMERIC_DT = {
    XSD.integer, XSD.int, XSD.long, XSD.short, XSD.byte,
    XSD.unsignedInt, XSD.unsignedShort, XSD.unsignedByte, XSD.unsignedLong,
    XSD.nonNegativeInteger, XSD.nonPositiveInteger, XSD.positiveInteger, XSD.negativeInteger,
    XSD.decimal, XSD.double, XSD.float
}

def load_graph() -> Graph:
    assert DATA_DIR.exists(), f"Missing data dir: {DATA_DIR}"
    g = Graph()
    ttls = sorted(DATA_DIR.glob("*.ttl"))
    mods = DATA_DIR / "modules"
    if mods.exists():
        ttls += sorted(mods.glob("*.ttl"))

    parsed_any = False
    errors = []
    for ttl in ttls:
        try:
            g.parse(str(ttl), format="turtle")
            parsed_any = True
        except Exception as e:
            try:
                txt = ttl.read_text(encoding="utf-8", errors="replace")
            except Exception:
                txt = "<unable to read file>"
            tail = "\n".join(txt.splitlines()[-40:])
            errors.append(f"\n--- Parse error in {ttl} ---\n{e}\nLast 40 lines:\n{tail}\n")
    assert parsed_any, f"No .ttl files found under {DATA_DIR}."
    assert not errors, "".join(errors)
    return g


INIT_NS = {"rdf": RDF, "rdfs": RDFS, "owl": OWL, "skos": SKOS, "xsd": XSD}

def run_query(g: Graph, q: str):
    return g.query(q, initNs=INIT_NS)

def ask(g: Graph, q: str) -> bool:
    q_str = q.strip()
    # If caller already sent a full ASK query, run it directly.
    if q_str[:3].upper() == "ASK":
        return bool(run_query(g, q_str).askAnswer)
    # Otherwise, treat the string as a WHERE body.
    return bool(run_query(g, f"ASK {{ {q_str} }}").askAnswer)

def rows(g: Graph, q: str):
    return list(run_query(g, q))


def by_label_iri(g: Graph, label: str):
    q = f"""
    SELECT ?s WHERE {{
      ?s rdfs:label ?l .
      FILTER(LCASE(STR(?l)) = LCASE("{label}"))
    }}
    """
    return [r[0] for r in rows(g, q)]

def require_labeled_and_defined(g: Graph, label: str):
    q = f"""
    ASK {{
      ?s rdfs:label ?l .
      FILTER(LCASE(STR(?l)) = LCASE("{label}"))
      ?s skos:definition ?d .
    }}
    """
    assert ask(g, q), f"Resource with rdfs:label '{label}' must exist and have a skos:definition."

def avg_numeric_for_parts(g: Graph, process_iri: URIRef):
    # Collect numeric literals attached to any immediate parts that point (is temporal part of) to this process.
    # We'll accept any predicate from the part to a numeric literal.
    q = f"""
    SELECT ?part ?val WHERE {{
      ?part ?ptOf <{process_iri}> .
      ?ptOf rdfs:label ?ptOfLabel .
      FILTER(CONTAINS(LCASE(STR(?ptOfLabel)), "temporal part"))
      ?part ?p ?val .
      FILTER(isLiteral(?val) && datatype(?val) IN ({", ".join(f"<{dt}>" for dt in NUMERIC_DT)}))
    }}
    """
    vs = [float(str(r["val"])) for r in rows(g, q)]
    if not vs:
        return None, 0
    return sum(vs) / len(vs), len(vs)

# ---- Core / existence tests ---------------------------------------------------

def test_required_files_present_and_parsable():
    g = load_graph()
    core = DATA_DIR / "core.ttl"
    inst = DATA_DIR / "instances.ttl"
    assert core.exists(), f"Missing required file: {core}"
    assert inst.exists(), f"Missing required file: {inst}"

def test_required_terms_have_labels_and_definitions():
    g = load_graph()
    # Key terms called out in the spec; must exist somewhere in the submission with label+definition
    key_terms = [
        # Task 1
        "Artifact Design", "Jet Engine", "Fixed Wing",
        "has continuant part", "has Model BADA", "has Model FAA",
        "has Length Ft", "has Tail Height Ft", "is about",
        # Task 2
        "Test Process", "is temporal part of", "is measurement unit of",
        "prescribes", "Measurement Unit",
        # Task 3
        "Act of Aircraft Processing", "Adaptability Evaluation",
        # Task 4
        "quality", "Act of Measuring", "Total Employment",
        "has area", "o group", "own code",
    ]
    # Some students may write "Tail HeightFt" (no space). Accept either spelling for the label requirement.
    alternates = {"has Tail Height Ft": ["has Tail Height Ft", "has Tail HeightFt"]}

    for term in key_terms:
        if term in alternates:
            ok = False
            for alt in alternates[term]:
                if ask(load_graph(), f'?s rdfs:label ?l . FILTER(LCASE(STR(?l)) = LCASE("{alt}")) ?s skos:definition ?d .'):
                    ok = True
                    break
            assert ok, f"Resource labeled '{term}' (or allowed variant) must exist with skos:definition."
        else:
            require_labeled_and_defined(g, term)

def test_basic_bfo_conformance_checks():
    g = load_graph()
    # Labels for BFO targets (students may import BFO with standard labels)
    bfo_targets = {
        "material entity": "Jet Engine",
        "process": "Test Process",
        "generically dependent continuant": "Artifact Design",
    }
    for bfo_label, local_label in bfo_targets.items():
        q = f"""
        ASK {{
          ?local rdfs:label ?llab .
          FILTER(LCASE(STR(?llab)) = LCASE("{local_label}"))
          ?bfo rdfs:label ?bfolab .
          FILTER(LCASE(STR(?bfolab)) = LCASE("{bfo_label}"))
          ?local rdfs:subClassOf* ?bfo .
        }}
        """
        assert ask(g, q), (
            f"BFO conformance failed: '{local_label}' must be rdfs:subClassOf* '{bfo_label}'. "
            f"Ensure you import BFO (or a BFO-conformant bridge) and use correct subclassing."
        )

# ---- Task 1 -------------------------------------------------------------------

def test_task1_a320neo_spec_modeled():
    g = load_graph()

    # Find the A320 NEO spec node by label
    a320_nodes = by_label_iri(g, "Airbus A320 NEO")
    assert a320_nodes, "Must have an instance with rdfs:label 'Airbus A320 NEO'."
    a320 = a320_nodes[0]

    # (a) Exactly two Jet Engines via 'has continuant part'
    q_engines = f"""
    SELECT (COUNT(DISTINCT ?e) AS ?n) WHERE {{
      <{a320}> ?hascp ?e .
      ?hascp rdfs:label ?cpLab .
      FILTER(LCASE(STR(?cpLab)) = LCASE("has continuant part"))
      ?e rdf:type ?eType .
      ?eType rdfs:label ?eTypeLab .
      FILTER(LCASE(STR(?eTypeLab)) = LCASE("Jet Engine"))
    }}
    """
    rows_eng = rows(g, q_engines)
    n = int(rows_eng[0]["n"]) if rows_eng else 0
    assert n == 2, f"A320 NEO must have exactly 2 'Jet Engine' parts via 'has continuant part', found {n}."

    # (b) Airbus as manufacturer (be lenient: any predicate whose label contains 'manufacturer' to an object labeled containing 'Airbus')
    q_mfg = f"""
    ASK {{
      <{a320}> ?p ?airbus .
      ?p rdfs:label ?plab .
      FILTER(CONTAINS(LCASE(STR(?plab)), "manufacturer"))
      ?airbus rdfs:label ?alab .
      FILTER(CONTAINS(LCASE(STR(?alab)), "airbus"))
    }}
    """
    assert ask(g, q_mfg), "A320 NEO must indicate Airbus as manufacturer using a predicate labeled (contains) 'manufacturer'."

    # (c) BADA/FAA codes typed (any literal with a datatype)
    q_codes = f"""
    ASK {{
    <{a320}> ?p1 ?bada ;
           ?p2 ?faa .
        ?p1 rdfs:label ?l1 .
        ?p2 rdfs:label ?l2 .
        FILTER(LCASE(STR(?l1)) = LCASE("has Model BADA"))
        FILTER(LCASE(STR(?l2)) = LCASE("has Model FAA"))
        FILTER(isLiteral(?bada))
        FILTER(isLiteral(?faa))
        BIND(DATATYPE(?bada) AS ?dtB)
        BIND(DATATYPE(?faa)  AS ?dtF)
        FILTER(BOUND(?dtB) && BOUND(?dtF))
    }}
    """


    assert ask(g, q_codes), "A320 NEO must have typed BADA/FAA codes via 'has Model BADA' and 'has Model FAA'."

    # (d) length and tail height typed as numeric literals
    # accept either 'has Tail Height Ft' or 'has Tail HeightFt'
    q_dims = f"""
    ASK {{
      <{a320}> ?lenP ?len ;
               ?thP ?th .
      ?lenP rdfs:label ?lenLab .
      FILTER(LCASE(STR(?lenLab)) = LCASE("has Length Ft"))
      ?thP rdfs:label ?thLab .
      FILTER(LCASE(STR(?thLab)) = LCASE("has Tail Height Ft") || LCASE(STR(?thLab)) = LCASE("has Tail HeightFt"))
      FILTER(isLiteral(?len) && datatype(?len) IN ({", ".join(f"<{dt}>" for dt in NUMERIC_DT)}))
      FILTER(isLiteral(?th)  && datatype(?th)  IN ({", ".join(f"<{dt}>" for dt in NUMERIC_DT)}))
    }}
    """
    assert ask(g, q_dims), "A320 NEO must have numeric 'has Length Ft' and 'has Tail Height Ft/Tf' values with numeric xsd datatypes."

# ---- Task 2 -------------------------------------------------------------------

def test_task2_a321111_and_test_process():
    g = load_graph()

    # (a) A321-111 prescribes 142 knots via a measurement unit
    a321_nodes = by_label_iri(g, "Airbus A321-111")
    assert a321_nodes, "Must have an instance with rdfs:label 'Airbus A321-111'."
    a321 = a321_nodes[0]

    q_prescribes = f"""
    ASK {{
      <{a321}> ?pres ?target .
      ?pres rdfs:label ?plab .
      FILTER(LCASE(STR(?plab)) = LCASE("prescribes"))
      # Find a numeric value 142 with a unit 'knot'/'knots' attached to the target in some way.
      {{
        ?target ?p ?lit .
        FILTER(isLiteral(?lit) && xsd:integer(?lit) = 142)
      }}
      UNION
      {{
        ?target ?p ?node .
        ?node ?p2 ?lit .
        FILTER(isLiteral(?lit) && xsd:integer(?lit) = 142)
      }}
      # Any linkage indicating measurement unit involvement
      ?mu rdfs:label ?mulab .
      FILTER(CONTAINS(LCASE(STR(?mulab)), "knot"))
      ?muRel rdfs:label ?rLab .
      FILTER(LCASE(STR(?rLab)) = LCASE("is measurement unit of"))
      ?muRel ?x ?y .  # ensure relation resource exists; we don't enforce direct triple shape to stay flexible
    }}
    """
    assert ask(g, q_prescribes), (
        "A321-111 must 'prescribe' a value 142 with a measurement unit indicating knots "
        "(flexible structure allowed; ensure labels and typed literal 142 are present)."
    )

    # (b) A Test Process with 5 approach parts whose average maximum approach speed is 139
    # Find a Test Process instance
    q_testproc = """
    SELECT ?tp WHERE {
      ?tp rdf:type ?tpType .
      ?tpType rdfs:label ?tLab .
      FILTER(LCASE(STR(?tLab)) = LCASE("Test Process"))
    } LIMIT 5
    """
    tps = [r["tp"] for r in rows(g, q_testproc)]
    assert tps, "Must have at least one instance of 'Test Process'."

    # For at least one Test Process, verify (i) exactly 5 temporal parts exist; (ii) their numeric values average to 139
    ok = False
    for tp in tps:
        # count temporal parts
        q_parts = f"""
        SELECT (COUNT(DISTINCT ?part) AS ?n) WHERE {{
          ?part ?ptOf <{tp}> .
          ?ptOf rdfs:label ?l .
          FILTER(CONTAINS(LCASE(STR(?l)), "temporal part"))
        }}
        """
        rs = rows(g, q_parts)
        cnt = int(rs[0]["n"]) if rs else 0
        if cnt != 5:
            continue
        avg, nvals = avg_numeric_for_parts(g, tp)
        if nvals >= 5 and avg is not None and round(avg) == 139:
            ok = True
            break
    assert ok, (
        "A 'Test Process' must have exactly 5 temporal parts with numeric values averaging to 139 (rounded). "
        "Attach numeric literals to each temporal part (any predicate) so the autograder can find them."
    )

# ---- Task 3 -------------------------------------------------------------------

def test_task3_soc_aerospace_engineer_entries_and_pattern():
    g = load_graph()

    # Exactly 3 SOC entries that mention "Aerospace Engineer" (case-insensitive)
    q_soc = """
    SELECT ?s WHERE {
        ?s rdfs:label ?l .
        FILTER(STRSTARTS(STR(?l), "SOC:") && CONTAINS(LCASE(STR(?l)), "aerospace engineer"))
    }
    """

    socs = [r["s"] for r in rows(g, q_soc)]
    assert len(socs) == 3, f"Expected exactly 3 SOC_* entries mentioning 'Aerospace Engineer'; found {len(socs)}."

    # Each must have a skos:definition
    for s in socs:
        q_def = f"ASK {{ <{s}> skos:definition ?d . }}"
        assert ask(g, q_def), f"SOC entry {s} must have a skos:definition."

    # Pattern sanity: ensure the named activity/output terms appear in meaningful relations
    pattern_checks = [
        # is about: something is about Artifact Design
        """
        ASK {
          ?x ?p ?ad .
          ?p rdfs:label ?pl .
          FILTER(LCASE(STR(?pl)) = LCASE("is about"))
          ?ad rdfs:label ?adl .
          FILTER(LCASE(STR(?adl)) = LCASE("Artifact Design"))
        }
        """,
        # realizes: Act of Aircraft Processing realizes Adaptability Evaluation
        """
        ASK {
          ?aap rdf:type ?t1 .
          ?t1 rdfs:label ?l1 .
          FILTER(LCASE(STR(?l1)) = LCASE("Act of Aircraft Processing"))
          ?aap ?r ?ae .
          ?r rdfs:label ?rl .
          FILTER(LCASE(STR(?rl)) = LCASE("realizes"))
          ?ae rdf:type ?t2 .
          ?t2 rdfs:label ?l2 .
          FILTER(LCASE(STR(?l2)) = LCASE("Adaptability Evaluation"))
        }
        """,
        # is output of present somewhere
        """
        ASK {
          ?out ?rel ?proc .
          ?rel rdfs:label ?l .
          FILTER(LCASE(STR(?l)) = LCASE("is output of"))
        }
        """,
        # inheres in used somewhere
        """
        ASK {
          ?q ?rel ?bearer .
          ?rel rdfs:label ?l .
          FILTER(LCASE(STR(?l)) = LCASE("inheres in"))
        }
        """,
    ]
    for i, chk in enumerate(pattern_checks, 1):
        assert ask(g, chk), f"Task 3 pattern check #{i} failed. Ensure the indicated relation/terms are used."

# ---- Task 4 -------------------------------------------------------------------

def test_task4_occ_aerospace_engineer_entries_and_employment_pattern():
    g = load_graph()

    # Exactly 3 OCC entries that mention "Aerospace Engineer"
    q_occ = """
    SELECT ?s WHERE {
        ?s rdfs:label ?l .
        FILTER(STRSTARTS(STR(?l), "OCC:") && CONTAINS(LCASE(STR(?l)), "aerospace engineer"))
    }
    """

    occs = [r["s"] for r in rows(g, q_occ)]
    assert len(occs) == 3, f"Expected exactly 3 OCC_* entries mentioning 'Aerospace Engineer'; found {len(occs)}."

    # All three must have all columns modeled somehow (we enforce presence of a definition and at least one numeric measure)
    for s in occs:
        assert ask(g, f"ASK {{ <{s}> skos:definition ?d . }}"), f"OCC entry {s} must have a skos:definition."

    # Pattern: population -> Act of Measuring -> Total Employment (numeric), plus ancillary terms present
    # We'll verify:
    #  - There exists a node labeled 'Total Employment' connected to some numeric literal.
    #  - There exists a node typed/used with label 'Act of Measuring'.
    #  - Properties 'has area', 'o group', 'own code' exist somewhere (label+definition were checked above).
    q_total_emp_numeric = """
    ASK {
      ?te rdfs:label ?l .
      FILTER(LCASE(STR(?l)) = LCASE("Total Employment"))
      ?te ?p ?v .
      FILTER(isLiteral(?v) && datatype(?v) IN (
        xsd:integer, xsd:int, xsd:long, xsd:short, xsd:byte,
        xsd:unsignedInt, xsd:unsignedShort, xsd:unsignedByte, xsd:unsignedLong,
        xsd:nonNegativeInteger, xsd:nonPositiveInteger, xsd:positiveInteger, xsd:negativeInteger,
        xsd:decimal, xsd:double, xsd:float
      ))
    }
    """
    assert ask(g, q_total_emp_numeric), "There must be a 'Total Employment' node with at least one numeric literal value."

    q_act_measuring = """
    ASK {
      ?x ?p ?y .
      {
        ?x rdf:type ?t .
        ?t rdfs:label ?l .
        FILTER(LCASE(STR(?l)) = LCASE("Act of Measuring"))
      } UNION {
        ?y rdf:type ?t2 .
        ?t2 rdfs:label ?l2 .
        FILTER(LCASE(STR(?l2)) = LCASE("Act of Measuring"))
      }
    }
    """
    assert ask(g, q_act_measuring), "Submission must use a class labeled 'Act of Measuring' in the measurement pattern."

    # Verify at least one numeric total is present (redundant to first but emphasizes grading item)
    q_any_numeric_total = """
    ASK {
      ?s rdfs:label ?l .
      FILTER(CONTAINS(LCASE(STR(?l)), "total employment"))
      ?s ?p ?v .
      FILTER(isLiteral(?v) && (datatype(?v) = xsd:integer || datatype(?v) = xsd:decimal || datatype(?v) = xsd:double || datatype(?v) = xsd:float))
    }
    """
    assert ask(g, q_any_numeric_total), "At least one numeric total employment value must be present."

# ---- General RDF hygiene (labels + datatypes on literals used in tasks) -------

def test_literals_are_typed_and_task_instances_have_labels():
    g = load_graph()

    # (a) Ensure every literal in the graph is typed (best-effort; allow language-tagged string as 'typed enough')
    q_untyped = """
    SELECT ?s ?p ?o WHERE {
        ?s ?p ?o .
    FILTER(isLiteral(?o))
    BIND(DATATYPE(?o) AS ?dt)
    FILTER(!BOUND(?dt) && !langMatches(lang(?o), "*"))
    } LIMIT 1
    """

    no = rows(g, q_untyped)
    assert not no, (
        "All literals must have appropriate xsd datatypes (or a language tag). "
        f"Found at least one untyped literal triple like: {no[0] if no else ''}"
    )

    # (b) Ensure all task-named instances have labels
    required_instances = ["Airbus A320 NEO", "Airbus A321-111"]
    for lab in required_instances:
        assert by_label_iri(g, lab), f"Missing required instance labeled '{lab}'."

